객체지향 13주차

[ 인터페이스 ]

- 선언 방법 -
[접근제한자] interface 인터페이스명

- 인터페이스의 구성 멤버 -
=> 상수 필드
    -> 데이터 저장하지 않음
    -> 인터페이스에 선언된 모든 필드는 public static final()
    -> 대문자로 작성
    -> 선언과 동시에 초기화


=> 추상 메소드
    -> 인터페이스를 통해 호출된 메소드는 최종적으로 객체에서 실행
    -> 블록이 없는 추상 메소드로 선언
    -> public abstract를 생략해도 자동으로 컴파일 과정에서 붙게 됨


=> 디폴트 메소드
    -> [public] default 리턴타입 메소드명(매개변수,...){...}
    -> 실행 블록을 가지고 있는 메소드
    -> default 키워드를 반드시 붙여야 한다
    -> 기본적으로 public 접근 제한의 특성을 가짐
    -> 인터페이스의 모든 구현 객체가 가지고 있는 메소드로 반드시 가지고 있어야 함


=> 정적 메소드
    -> [public] static 리턴타입 메소드명(매개변수, ...) {...}
    -> 디폴트 메소드와 달리 객체가 없어도 인터페이스만으로 호출이 가능하다.



구현 클래스 선언
자신의 객체가 인터페이스 타입으로 사용할 수 있음
implements 키워드로 명시
    -> public class 구현클래스명 implements 인터페이스명 {...}




익명 구현 객체
명시적인 구현 클래스를 작성 생략하고 바로 구현 객체를 얻는 방법
인터페이스 변수 = new 인터페이스() {
    //인터페이스에 선언된 추상 메소드의 실제 메소드 선언
};
	// 모바일 프로그래밍에서 이벤트 처리 시 대부분 사용



다중 인터페이스 구현 클래스

-> public class 구현클래스명 implements 인터페이스 A, 인터페이스 B {
	// 인터페이스 A에 선언된 추상 메소드의 실체 메소드 선언
	// 인터페이스 B에 선언된 추상 메소드의 실체 메소드 선언
}




인터페이스에 구현 객체를 대입하는 방법

인터페이스 변수;
변수 = 구현객체;


인터페이스 변수 = 구현객체;

----------------------------------------------------------
Volume vol;
vol = new Radio();
vol = new TV();


Volume vol = new Radio();




추상 메소드 사용
RemoteControl rc = new Television();
rc.turnOn(); -> Television의 turnOn() 실행
rc.turnOff(); -> Television의 turnOff() 실행



디폴트 메소드 사용
인터페이스만으로는 사용 불가
-> 구현 객체가 인터페이스에 대입되어야 호출할 수 있는 인스턴스 메소드

모든 구현 객체가 가지고 있는 기본 메소드로 사용
-> 필요에 따라 구현 클래스가 디폴트 메소드 재정의해 사용




다형성
하나의 타입에 여러 가지 객체를 대입해 다양한 실행 결과를 얻는 것

다형성을 구현하는 기술
-> 상속 또는 인터페이스의 자동 타입 변환(Promotion)
-> 오버라이딩(Overriding)

다형성의 효과
-> 다양한 실행 결과를 얻을 수 있음
-> 객체를 부품화시킬 수 있어 유지보수 용이(메소드의 매개변수로 사용)



자동 타입 변환 (Promotion)
인터페이스 변수 = 구현객체; (자동 타입 변환)




매개 변수의 다형성
매개 변수의 타입이 인터페이스인 경우
-> 어떠한 구현 객체도 매개값으로 사용 가능
-> 구현 객체에 따라 메소드 실행결과 달라짐


강제 타입 변환(Casting)
인터페이스 타입으로 자동 타입 변환 후, 구현 클래스 타입으로 변환
    필요성: 구현 클래스 타입에 선언된 다른 멤버를 사용하기 위해


객체 타입 확인 (instanceof 연산자)
->강제 타입 변환 전 구현 클래스 타입 조사 



인터페이스간 상속
Public interface 하위인터페이스 extends 상위인터페이스1, 상위인터페이스2 {...}

하위 인터페이스 구현 클래스는 아래 추상 메소드를 모두 재정의해야 함

하위 인터페이스 추상 메소드		하위인터페이스 변수 = new 구현클래스{...}
상위 인터페이스1의 추상 메소드		상위인터페이스1 변수 = new 구현클래스{...}
상위 인터페이스2의 추상 메소드		상위인터페이스2 변수 = new 구현클래스{...}


인터페이스 자동 타입 변환
-> 해당 타입의 인터페이스에 선언된 메소드만 호출 가능



디폴트 메소드와 확장 메소드 사용









